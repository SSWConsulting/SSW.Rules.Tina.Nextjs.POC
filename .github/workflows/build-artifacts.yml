name: Building Artifact depending on environment passed in parameter

on:
    workflow_call:
        inputs:
            tag:
                type: string
                required: true
            tina_branch:
                type: string
                required: false
                default: ''
            source_branch:
                type: string
                required: false
                default: ''
                description: 'Source branch name that triggered this build'
            purge_cache:
                type: boolean
                required: false
                default: false
                description: 'Set to true to purge ALL GitHub Actions caches before build'
        secrets:
            AZURE_CLIENT_ID:
                required: true
            AZURE_TENANT_ID:
                required: true
            AZURE_SUBSCRIPTION_ID:
                required: true
            TINA_TOKEN:
                required: false
            NEXT_PUBLIC_TINA_CLIENT_ID:
                required: false
            TOKEN:
                required: true
            NEXT_PUBLIC_ALGOLIA_APP_ID:
                required: false
            NEXT_PUBLIC_ALGOLIA_ADMIN_KEY:
                required: false
            NEXT_PUBLIC_ALGOLIA_INDEX_NAME:
                required: false
            NEXT_PUBLIC_ALGOLIA_API_KEY:
                required: false
            NEXT_PUBLIC_TINA_BRANCH:
                required: false
            NEXT_PUBLIC_API_BASE_URL:
                required: false
        outputs:
            image_tag:
                description: 'Docker tag to deploy'
                value: ${{ jobs.build-and-push.outputs.image_tag }}
            image_digest:
                value: ${{ jobs.build-and-push.outputs.image_digest }}
            build_timestamp:
                description: 'Build timestamp'
                value: ${{ jobs.build-and-push.outputs.build_timestamp }}
            build_date:
                description: 'Build date'
                value: ${{ jobs.build-and-push.outputs.build_date }}
            commit_hash:
                description: 'Commit hash'
                value: ${{ jobs.build-and-push.outputs.commit_hash }}
            version_deployed:
                description: 'Version deployed'
                value: ${{ jobs.build-and-push.outputs.version_deployed }}
            deployment_url:
                description: 'Deployment URL'
                value: ${{ jobs.build-and-push.outputs.deployment_url }}

defaults:
    run:
        shell: bash

jobs:
    build-and-push:
        runs-on: ubuntu-latest
        environment: ${{ inputs.tag }}
        outputs:
            image_tag: ${{ steps.meta.outputs.tags }}
            image_digest: ${{ steps.build.outputs.digest }}
            build_timestamp: ${{ env.BUILD_TIMESTAMP }}
            build_date: ${{ env.BUILD_DATE }}
            commit_hash: ${{ env.COMMIT_HASH }}
            version_deployed: ${{ env.VERSION_DEPLOYED }}
            deployment_url: ${{ env.DEPLOYMENT_URL }}
        steps:
            # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ BUILD INFO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            - name: Generate build information
              id: build_info
              run: |
                  BUILD_TIMESTAMP=$(date +%s)000
                  BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
                  COMMIT_HASH=$(echo "${{ github.sha }}" | cut -c1-7)
                  VERSION_DEPLOYED="${{ github.run_number }}"
                  DEPLOYMENT_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                  
                  echo "BUILD_TIMESTAMP=$BUILD_TIMESTAMP" >> $GITHUB_ENV
                  echo "BUILD_DATE=$BUILD_DATE" >> $GITHUB_ENV
                  echo "COMMIT_HASH=$COMMIT_HASH" >> $GITHUB_ENV
                  echo "VERSION_DEPLOYED=$VERSION_DEPLOYED" >> $GITHUB_ENV
                  echo "DEPLOYMENT_URL=$DEPLOYMENT_URL" >> $GITHUB_ENV
                  
                  echo "üèóÔ∏è Build Info Generated:"
                  echo "  Timestamp: $BUILD_TIMESTAMP"
                  echo "  Date: $BUILD_DATE"
                  echo "  Version: $VERSION_DEPLOYED"
                  echo "  Commit: $COMMIT_HASH"

            - name: Log build information
              run: |
                  echo "üöÄ Starting build process (NO CACHE MODE)"
                  echo "Source branch: ${{ inputs.source_branch || 'Not specified' }}"
                  echo "Tina branch: ${{ inputs.tina_branch || secrets.NEXT_PUBLIC_TINA_BRANCH || 'Default' }}"
                  echo "Environment tag: ${{ inputs.tag }}"
                  echo "Registry: ${{ vars.registry_name }}"
                  echo "Image: ${{ vars.IMAGE_NAME }}"
                  echo "Build timestamp: ${{ env.BUILD_TIMESTAMP }}"
                  echo "Build version: ${{ env.VERSION_DEPLOYED }}"
                  echo "üö´ Docker cache: DISABLED"
                  echo "üßπ Cache purge: ${{ inputs.purge_cache && 'ENABLED' || 'DISABLED' }}"

            # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CACHE ANALYSIS & PURGE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            - name: Analyze current cache status
              run: |
                  echo "üîç GitHub Actions Cache Analysis:"
                  echo "Repository: ${{ github.repository }}"
                  echo "Purge cache requested: ${{ inputs.purge_cache }}"
                  echo ""
                  
                  # Obtenir les statistiques actuelles du cache
                  CACHE_COUNT=$(gh api repos/${{ github.repository }}/actions/caches --paginate \
                    --jq '.actions_caches | length' 2>/dev/null || echo "0")
                  TOTAL_CACHE_SIZE=$(gh api repos/${{ github.repository }}/actions/caches --paginate \
                    --jq '[.actions_caches[] | .size_in_bytes] | add // 0' 2>/dev/null || echo "0")
                  
                  echo "üìä Current cache status:"
                  echo "Total caches: $CACHE_COUNT"
                  echo "Total size: $(echo $TOTAL_CACHE_SIZE | numfmt --to=iec --suffix=B)"
                  
                  # Sauvegarder pour usage ult√©rieur
                  echo "CACHE_COUNT_BEFORE=$CACHE_COUNT" >> $GITHUB_ENV
                  echo "TOTAL_CACHE_SIZE_BEFORE=$TOTAL_CACHE_SIZE" >> $GITHUB_ENV
                  
                  if [ $CACHE_COUNT -gt 0 ]; then
                    echo ""
                    echo "üóÇÔ∏è Cache breakdown by type:"
                    gh api repos/${{ github.repository }}/actions/caches --paginate \
                      --jq '.actions_caches[] | 
                      if .key | startswith("buildkit-blob") then "Docker-Layers"
                      elif .key | startswith("index-buildkit") then "Docker-Index" 
                      elif .key | contains("pnpm") then "PNPM-Cache"
                      elif .key | contains("npm") then "NPM-Cache"
                      elif .key | contains("yarn") then "Yarn-Cache"
                      else "Other"
                      end' \
                      | sort | uniq -c | while read count type; do
                        echo "  $type: $count entries"
                      done 2>/dev/null || echo "  Could not categorize caches"
                    
                    echo ""
                    echo "üìã Largest caches (top 5):"
                    gh api repos/${{ github.repository }}/actions/caches --paginate \
                      --jq '.actions_caches[] | {size_mb: (.size_in_bytes / 1048576 | floor), key: (.key | .[0:50] + "..."), created: .created_at}' \
                      | jq -s 'sort_by(.size_mb) | reverse | .[0:5][] | "  \(.size_mb)MB - \(.key) (\(.created))"' \
                      2>/dev/null || echo "  Could not list largest caches"
                  else
                    echo "‚úÖ No caches found"
                  fi
              env:
                  GH_TOKEN: ${{ github.token }}

            - name: Debug purge_cache parameter
              run: |
                  echo "üîç Debug purge_cache parameter:"
                  echo "inputs.purge_cache value: '${{ inputs.purge_cache }}'"
                  echo "inputs.purge_cache type: $(echo '${{ inputs.purge_cache }}' | wc -c) chars"
                  echo "String comparison: '${{ inputs.purge_cache }}' == 'true'"
                  echo "Boolean comparison: ${{ inputs.purge_cache == true }}"
                  echo "Boolean comparison (string): ${{ inputs.purge_cache == 'true' }}"
                  echo ""
                  
                  # FORCE PURGE FOR TESTING (remove this after testing)
                  echo "üß™ FORCING PURGE FOR TESTING - Remove this section after test"
                  echo "FORCE_PURGE=true" >> $GITHUB_ENV
                  
                  if [ "${{ inputs.purge_cache }}" = "true" ]; then
                    echo "‚úÖ Purge will be executed (parameter set to true)"
                  else
                    echo "‚ùå Parameter set to false, but FORCING for test"
                    echo "To enable purge normally, set purge_cache: true in workflow call"
                  fi

            - name: Purge all GitHub Actions caches
              if: ${{ inputs.purge_cache == true || inputs.purge_cache == 'true' || env.FORCE_PURGE == 'true' }}
              run: |
                  echo "üßπ CACHE PURGE REQUESTED - Deleting ALL caches"
                  echo "‚ö†Ô∏è  This will permanently delete $CACHE_COUNT_BEFORE caches ($TOTAL_CACHE_SIZE_BEFORE bytes)"
                  echo ""
                  
                  if [ "$CACHE_COUNT_BEFORE" -eq 0 ]; then
                    echo "‚úÖ No caches to purge"
                    exit 0
                  fi
                  
                  echo "üóëÔ∏è  Starting cache purge..."
                  
                  # Obtenir tous les IDs de cache
                  CACHE_IDS=$(gh api repos/${{ github.repository }}/actions/caches --paginate \
                    --jq '.actions_caches[].id' 2>/dev/null || echo "")
                  
                  if [ -z "$CACHE_IDS" ]; then
                    echo "‚úÖ No cache IDs found to delete"
                    exit 0
                  fi
                  
                  DELETED_COUNT=0
                  FAILED_COUNT=0
                  TOTAL_IDS=$(echo "$CACHE_IDS" | wc -l)
                  
                  echo "Found $TOTAL_IDS cache IDs to delete"
                  echo ""
                  
                  # Supprimer chaque cache (continuer m√™me en cas d'erreur)
                  for CACHE_ID in $CACHE_IDS; do
                    echo -n "Deleting cache ID $CACHE_ID... "
                    
                    # D√©sactiver temporairement l'arr√™t sur erreur
                    set +e
                    DELETE_RESULT=$(gh api -X DELETE repos/${{ github.repository }}/actions/caches/$CACHE_ID 2>&1)
                    DELETE_EXIT_CODE=$?
                    set -e
                    
                    if [ $DELETE_EXIT_CODE -eq 0 ]; then
                      echo "‚úÖ"
                      ((DELETED_COUNT++))
                    else
                      echo "‚ùå ($(echo "$DELETE_RESULT" | head -n1 | cut -c1-50)...)"
                      ((FAILED_COUNT++))
                    fi
                    
                    # Progress indicator
                    PROGRESS=$((DELETED_COUNT + FAILED_COUNT))
                    if [ $((PROGRESS % 10)) -eq 0 ]; then
                      echo "Progress: $PROGRESS/$TOTAL_IDS caches processed"
                    fi
                    
                    # Petite pause pour √©viter le rate limiting
                    sleep 0.1
                  done
                  
                  echo ""
                  echo "üìä Purge Results:"
                  echo "‚úÖ Successfully deleted: $DELETED_COUNT caches"
                  echo "‚ùå Failed to delete: $FAILED_COUNT caches"
                  echo "Space freed: $(echo $TOTAL_CACHE_SIZE_BEFORE | numfmt --to=iec --suffix=B)"
                  
                  # V√©rifier le r√©sultat
                  echo ""
                  echo "üîç Verifying purge results..."
                  sleep 3  # Attendre que l'API se mette √† jour
                  
                  REMAINING_CACHES=$(gh api repos/${{ github.repository }}/actions/caches --jq '.actions_caches | length' 2>/dev/null || echo "unknown")
                  echo "Remaining caches: $REMAINING_CACHES"
                  
                  if [ "$REMAINING_CACHES" = "0" ]; then
                    echo "üéâ SUCCESS: All caches have been purged!"
                  elif [ "$REMAINING_CACHES" = "unknown" ]; then
                    echo "‚è≥ Cache status unknown (API delay), check manually"
                  else
                    echo "‚ö†Ô∏è  $REMAINING_CACHES caches remain (may need time to reflect or failed deletions)"
                  fi
              env:
                  GH_TOKEN: ${{ github.token }}

            - name: Log post-purge status
              if: ${{ inputs.purge_cache == true || inputs.purge_cache == 'true' || env.FORCE_PURGE == 'true' }}
              run: |
                  echo "üìä Cache status after purge:"
                  CURRENT_CACHES=$(gh api repos/${{ github.repository }}/actions/caches --jq '.actions_caches | length' 2>/dev/null || echo "unknown")
                  CURRENT_SIZE=$(gh api repos/${{ github.repository }}/actions/caches --paginate \
                    --jq '[.actions_caches[] | .size_in_bytes] | add // 0' 2>/dev/null || echo "0")
                  
                  echo "Current caches: $CURRENT_CACHES"
                  echo "Current size: $(echo $CURRENT_SIZE | numfmt --to=iec --suffix=B)"
                  echo ""
                  echo "üí° Next build will:"
                  echo "‚Ä¢ Start with 0 cache (completely fresh)"
                  echo "‚Ä¢ Take longer to complete (8-15 minutes)"
                  echo "‚Ä¢ Build all Docker layers from scratch"
                  echo "‚Ä¢ Re-download all dependencies"
              env:
                  GH_TOKEN: ${{ github.token }}

            # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CHECKOUTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            - name: Checkout main repo
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0
                  lfs: true

            - name: Checkout SSW.Rules.Content
              uses: actions/checkout@v4
              with:
                  repository: SSWConsulting/SSW.Rules.Content
                  ref: ${{ inputs.tina_branch || secrets.NEXT_PUBLIC_TINA_BRANCH }}
                  token: ${{ secrets.TOKEN }}
                  path: content-temp
                  fetch-depth: 0
                  lfs: true

            # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PYTHON + MAPPING FILES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            - name: Setup Python
              uses: actions/setup-python@v4
              with:
                  python-version: '3.x'

            - name: Generate rule‚Äëcategory mapping files
              working-directory: content-temp/scripts/tina-migration
              run: python build-rule-category-map.py

            - name: Copy generated mapping + content
              run: |
                  cp content-temp/scripts/tina-migration/rule-to-categories.json ./
                  cp content-temp/scripts/tina-migration/category-uri-title-map.json ./
                  mv content-temp ./content

            # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ AZURE LOGIN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            - name: Azure CLI ‚Äì Login
              uses: azure/login@v2
              with:
                  client-id: ${{ secrets.AZURE_CLIENT_ID }}
                  tenant-id: ${{ secrets.AZURE_TENANT_ID }}
                  subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

            - name: Login to ACR
              run: az acr login --name ${{ vars.registry_name }}

            # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DOCKER BUILD (NO CACHE) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            - name: Set up Docker Buildx (no cache)
              uses: docker/setup-buildx-action@v3
              with:
                driver-opts: |
                  env.BUILDKIT_STEP_LOG_MAX_SIZE=10485760
                  env.BUILDKIT_STEP_LOG_MAX_SPEED=10485760

            - name: Log no-cache build strategy
              run: |
                  echo "üö´ NO CACHE BUILD STRATEGY:"
                  echo "‚Ä¢ Docker layers will be built from scratch"
                  echo "‚Ä¢ npm/yarn dependencies will be downloaded fresh"
                  echo "‚Ä¢ Build time will be longer but completely fresh"
                  echo "‚Ä¢ No cache dependencies or corruption risks"
                  if [ "${{ inputs.purge_cache }}" = "true" ]; then
                    echo "‚Ä¢ All previous caches have been purged"
                  fi
                  echo ""
                  echo "‚è±Ô∏è Expected build time: 8-15 minutes (vs 2-5 min with cache)"

            - name: Extract metadata (tags, labels)
              id: meta
              uses: docker/metadata-action@v5
              with:
                  images: ${{ vars.registry_name }}.azurecr.io/${{ vars.image_name }}
                  tags: |
                      type=raw,value=${{ inputs.tag }}
                  labels: |
                      org.opencontainers.image.source.branch=${{ inputs.source_branch }}
                      org.opencontainers.image.tina.branch=${{ inputs.tina_branch || secrets.NEXT_PUBLIC_TINA_BRANCH }}
                      org.opencontainers.image.build.timestamp=${{ env.BUILD_TIMESTAMP }}
                      org.opencontainers.image.build.version=${{ env.VERSION_DEPLOYED }}
                      org.opencontainers.image.build.commit=${{ env.COMMIT_HASH }}
                      org.opencontainers.image.build.cache=disabled
                      org.opencontainers.image.build.purged=${{ inputs.purge_cache }}

            - name: Create Dockerfile (no cache optimizations)
              run: |
                  cat > Dockerfile <<'EOF'
                  FROM node:18-alpine AS base

                  FROM base AS deps
                  RUN apk add --no-cache libc6-compat git-lfs
                  WORKDIR /app
                  COPY package*.json ./
                  COPY yarn.lock* ./
                  # Force fresh install every time (no cache)
                  RUN if [ -f yarn.lock ]; then yarn --frozen-lockfile --cache-folder /tmp/yarn-cache; \
                      elif [ -f package-lock.json ]; then npm ci --force --cache /tmp/npm-cache; \
                      else npm install --force --cache /tmp/npm-cache; fi

                  FROM base AS builder
                  WORKDIR /app
                  COPY --from=deps /app/node_modules ./node_modules
                  COPY . .
                  RUN git lfs pull || true

                  # Build arguments for build info
                  ARG BUILD_TIMESTAMP
                  ARG VERSION_DEPLOYED
                  ARG DEPLOYMENT_URL
                  ARG BUILD_DATE
                  ARG COMMIT_HASH

                  # Existing build arguments
                  ARG TINA_TOKEN
                  ARG NEXT_PUBLIC_TINA_CLIENT_ID
                  ARG NEXT_PUBLIC_TINA_BRANCH
                  ARG NEXT_PUBLIC_ALGOLIA_APP_ID
                  ARG NEXT_PUBLIC_ALGOLIA_ADMIN_KEY
                  ARG NEXT_PUBLIC_ALGOLIA_INDEX_NAME
                  ARG NEXT_PUBLIC_ALGOLIA_API_KEY
                  ARG NEXT_PUBLIC_API_BASE_URL
                  ARG NEXT_PUBLIC_GITHUB_ORG
                  ARG NEXT_PUBLIC_GITHUB_REPO
                  ARG NEXT_PUBLIC_GISCUS_REPO_NAME
                  ARG NEXT_PUBLIC_GISCUS_REPO_ID
                  ARG NEXT_PUBLIC_GISCUS_CATEGORY_ID
                  ARG NEXT_PUBLIC_GISCUS_THEME_URL

                  # Environment variables for build info (available at build time and runtime)
                  ENV BUILD_TIMESTAMP=$BUILD_TIMESTAMP \
                        VERSION_DEPLOYED=$VERSION_DEPLOYED \
                        DEPLOYMENT_URL=$DEPLOYMENT_URL \
                        BUILD_DATE=$BUILD_DATE \
                        COMMIT_HASH=$COMMIT_HASH \
                        TINA_TOKEN=$TINA_TOKEN \
                        NEXT_PUBLIC_TINA_CLIENT_ID=$NEXT_PUBLIC_TINA_CLIENT_ID \
                        NEXT_PUBLIC_TINA_BRANCH=$NEXT_PUBLIC_TINA_BRANCH \
                        NEXT_PUBLIC_ALGOLIA_APP_ID=$NEXT_PUBLIC_ALGOLIA_APP_ID \
                        NEXT_PUBLIC_ALGOLIA_ADMIN_KEY=$NEXT_PUBLIC_ALGOLIA_ADMIN_KEY \
                        NEXT_PUBLIC_ALGOLIA_INDEX_NAME=$NEXT_PUBLIC_ALGOLIA_INDEX_NAME \
                        NEXT_PUBLIC_ALGOLIA_API_KEY=$NEXT_PUBLIC_ALGOLIA_API_KEY \
                        NEXT_PUBLIC_GITHUB_ORG=$NEXT_PUBLIC_GITHUB_ORG \
                        NEXT_PUBLIC_GITHUB_REPO=$NEXT_PUBLIC_GITHUB_REPO \
                        NEXT_PUBLIC_GISCUS_REPO_NAME=$NEXT_PUBLIC_GISCUS_REPO_NAME \
                        NEXT_PUBLIC_GISCUS_REPO_ID=$NEXT_PUBLIC_GISCUS_REPO_ID \
                        NEXT_PUBLIC_GISCUS_CATEGORY_ID=$NEXT_PUBLIC_GISCUS_CATEGORY_ID \
                        NEXT_PUBLIC_GISCUS_THEME_URL=$NEXT_PUBLIC_GISCUS_THEME_URL \
                        NEXT_TELEMETRY_DISABLED=1

                  # Fresh build every time
                  RUN if [ -f yarn.lock ]; then yarn build; else npm run build; fi

                  FROM base AS runner
                  WORKDIR /app

                  # Environment variables for runtime
                  ENV NODE_ENV=production \
                      NEXT_TELEMETRY_DISABLED=1 \
                      PORT=3000 \
                      HOSTNAME="0.0.0.0"

                  # Copy build info to runtime stage
                  ARG BUILD_TIMESTAMP
                  ARG VERSION_DEPLOYED
                  ARG DEPLOYMENT_URL
                  ARG BUILD_DATE
                  ARG COMMIT_HASH

                  ENV BUILD_TIMESTAMP=$BUILD_TIMESTAMP \
                      VERSION_DEPLOYED=$VERSION_DEPLOYED \
                      DEPLOYMENT_URL=$DEPLOYMENT_URL \
                      BUILD_DATE=$BUILD_DATE \
                      COMMIT_HASH=$COMMIT_HASH

                  RUN addgroup -S nodejs -g 1001 && adduser -S nextjs -u 1001
                  COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
                  COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static
                  COPY --from=builder /app/public ./public
                  USER nextjs
                  EXPOSE 3000
                  CMD ["node", "server.js"]
                  EOF

            - name: Record build start time
              run: |
                  echo "BUILD_START_TIME=$(date +%s)" >> $GITHUB_ENV
                  echo "üèóÔ∏è Starting fresh build at $(date)"

            - name: Build & push image (NO CACHE)
              id: build
              uses: docker/build-push-action@v5
              with:
                  context: .
                  platforms: linux/amd64
                  push: true
                  tags: ${{ steps.meta.outputs.tags }}
                  labels: ${{ steps.meta.outputs.labels }}
                  build-args: |
                        BUILD_TIMESTAMP=${{ env.BUILD_TIMESTAMP }}
                        VERSION_DEPLOYED=${{ env.VERSION_DEPLOYED }}
                        DEPLOYMENT_URL=${{ env.DEPLOYMENT_URL }}
                        BUILD_DATE=${{ env.BUILD_DATE }}
                        COMMIT_HASH=${{ env.COMMIT_HASH }}
                        TINA_TOKEN=${{ secrets.TINA_TOKEN }}
                        NEXT_PUBLIC_TINA_CLIENT_ID=${{ secrets.NEXT_PUBLIC_TINA_CLIENT_ID }}
                        NEXT_PUBLIC_ALGOLIA_APP_ID=${{ secrets.NEXT_PUBLIC_ALGOLIA_APP_ID }}
                        NEXT_PUBLIC_ALGOLIA_ADMIN_KEY=${{ secrets.NEXT_PUBLIC_ALGOLIA_ADMIN_KEY }}
                        NEXT_PUBLIC_ALGOLIA_INDEX_NAME=${{ secrets.NEXT_PUBLIC_ALGOLIA_INDEX_NAME }}
                        NEXT_PUBLIC_ALGOLIA_API_KEY=${{ secrets.NEXT_PUBLIC_ALGOLIA_API_KEY }}
                        NEXT_PUBLIC_TINA_BRANCH=${{ inputs.tina_branch || secrets.NEXT_PUBLIC_TINA_BRANCH }}
                        NEXT_PUBLIC_GITHUB_ORG=${{ vars.NEXT_PUBLIC_GITHUB_ORG }}
                        NEXT_PUBLIC_GITHUB_REPO=${{ vars.NEXT_PUBLIC_GITHUB_REPO }}
                        NEXT_PUBLIC_GISCUS_REPO_NAME=${{ vars.NEXT_PUBLIC_GISCUS_REPO_NAME }}
                        NEXT_PUBLIC_GISCUS_REPO_ID=${{ vars.NEXT_PUBLIC_GISCUS_REPO_ID }}
                        NEXT_PUBLIC_GISCUS_CATEGORY_ID=${{ vars.NEXT_PUBLIC_GISCUS_CATEGORY_ID }}
                        NEXT_PUBLIC_GISCUS_THEME_URL=${{ vars.NEXT_PUBLIC_GISCUS_THEME_URL }}
                        NEXT_PUBLIC_API_BASE_URL=${{ secrets.NEXT_PUBLIC_API_BASE_URL }}
                  # CACHE COMPLETELY DISABLED
                  no-cache: true

            - name: Record build completion and analyze performance
              run: |
                  BUILD_END_TIME=$(date +%s)
                  BUILD_DURATION=$((BUILD_END_TIME - BUILD_START_TIME))
                  
                  echo "üèÅ Build completed at $(date)"
                  echo "‚è±Ô∏è Total build time: ${BUILD_DURATION} seconds ($(($BUILD_DURATION / 60))m $(($BUILD_DURATION % 60))s)"
                  
                  echo ""
                  echo "üìä No-Cache Build Performance:"
                  if [ $BUILD_DURATION -lt 300 ]; then
                    echo "üöÄ UNEXPECTEDLY FAST (< 5min) - Check if cache was actually disabled"
                  elif [ $BUILD_DURATION -lt 600 ]; then
                    echo "‚ö° FAST FOR NO-CACHE (5-10min) - Good server performance"
                  elif [ $BUILD_DURATION -lt 900 ]; then
                    echo "üîß NORMAL NO-CACHE TIME (10-15min) - Expected performance"
                  else
                    echo "üêå SLOW BUILD (>15min) - Heavy application or server issues"
                  fi
                  
                  echo ""
                  echo "üí≠ Build Analysis:"
                  echo "‚Ä¢ Every layer built from scratch"
                  echo "‚Ä¢ All dependencies downloaded fresh"
                  if [ "${{ inputs.purge_cache }}" = "true" ]; then
                    echo "‚Ä¢ All previous caches were purged"
                  fi
                  echo "‚Ä¢ No cache corruption risks"
                  echo "‚Ä¢ Longer build time but maximum reliability"

            - name: Final cache status summary
              run: |
                  echo "üìä Final Cache Status Summary:"
                  echo ""
                  
                  FINAL_CACHES=$(gh api repos/${{ github.repository }}/actions/caches --jq '.actions_caches | length' 2>/dev/null || echo "unknown")
                  FINAL_SIZE=$(gh api repos/${{ github.repository }}/actions/caches --paginate \
                    --jq '[.actions_caches[] | .size_in_bytes] | add // 0' 2>/dev/null || echo "0")
                  
                  echo "üèÅ FINAL STATUS:"
                  echo "Caches at start: $CACHE_COUNT_BEFORE"
                  echo "Cache purge requested: ${{ inputs.purge_cache }}"
                  echo "Caches now: $FINAL_CACHES"
                  echo "Current cache size: $(echo $FINAL_SIZE | numfmt --to=iec --suffix=B)"
                  
                  if [ "${{ inputs.purge_cache }}" = "true" ]; then
                    if [ "$FINAL_CACHES" = "0" ]; then
                      echo "‚úÖ SUCCESS: All caches purged successfully!"
                    else
                      echo "‚ö†Ô∏è  Some caches remain: $FINAL_CACHES (may need time to reflect)"
                    fi
                  else
                    echo "‚ÑπÔ∏è  No cache purge was requested"
                  fi
                  
                  echo ""
                  echo "üí° To enable cache for future builds:"
                  echo "‚Ä¢ Remove 'no-cache: true' from build step"
                  echo "‚Ä¢ Add 'cache-from: type=gha' and 'cache-to: type=gha,mode=max'"
                  echo "‚Ä¢ Set 'purge_cache: false' when calling this workflow"
              env:
                  GH_TOKEN: ${{ github.token }}

            - name: Image info
              run: |
                  echo "‚úÖ NO-CACHE Build completed successfully!"
                  echo "Image tag   : ${{ steps.meta.outputs.tags }}"
                  echo "Image digest: ${{ steps.build.outputs.digest }}"
                  echo "Source branch: ${{ inputs.source_branch || 'Not specified' }}"
                  echo "Content branch: ${{ inputs.tina_branch || secrets.NEXT_PUBLIC_TINA_BRANCH }}"
                  echo "Build Info:"
                  echo "  üìÖ Build Date: ${{ env.BUILD_DATE }}"
                  echo "  üè∑Ô∏è Version: ${{ env.VERSION_DEPLOYED }}"
                  echo "  üîó Deployment URL: ${{ env.DEPLOYMENT_URL }}"
                  echo "  üìù Commit: ${{ env.COMMIT_HASH }}"
                  echo "  üö´ Cache: DISABLED"
                  echo "  üßπ Purged: ${{ inputs.purge_cache && 'YES' || 'NO' }}"